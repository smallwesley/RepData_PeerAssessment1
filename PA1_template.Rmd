---
title: "Reproducible Data Coursera; Peer Assignment 1"
author: "Wesley Small"
date: "August 8, 2015"
output: 
  html_document: 
    keep_md: yes
    self_contained: no
---
```{r task0prep1, echo=FALSE, eval=FALSE}
# PART ZERO: PREP
setwd("/Users/smallwes/develop/academic/coursera/datascience/c5-repdata/pa1")
```

### Preliminary activities
1. Load libraries DPLYR, LUBRIDATE AND GGPLOT2.
```{r task0prep2, echo=FALSE, eval=TRUE, message=FALSE}
# EVALUATE IF LIBRARIES NOT INSTALLED
if (!"dplyr" %in% installed.packages()){ install.packages("dplyr") } 
if (!"lubridate" %in% installed.packages()){ install.packages("lubridate") } 
if (!"ggplot2" %in% installed.packages()){ install.packages("ggplot2") } 
```
```{r task0prep3, echo=TRUE, eval=TRUE, message=FALSE}
library(dplyr)
library(lubridate)
library(ggplot2)
```

2. Helper functions created for tidy data/plotting; Setup for the step interval scale to the logical hour and associated label.
```{r task0prephelpers}
intervalDivision <- split( 0:288, ceiling(seq_along(0:288)/12))

getStepScaleBreaks <- function() { 
    output <- numeric(length = 25) 
    for(i in 1:25) 
        output[i] <-intervalDivision[[i]][1] 
    output
}

getStepScaleLabels <- function() { 
    output <- numeric(length = 25) 
    for(i in 1:25) {
        dayPeriod <-"am"
        if (i > 13) dayPeriod <- "pm"
        output[i] <- paste0(i-1,":00 ", dayPeriod)
    }
    output
}
```

***
### TASK 1: "Load the data"
Load the dataset and perform some tranformations suitable for further analysis below.
```{r task1step1load}
dfActivity <- read.csv("activity.csv")
```

Transformations to original dataset:
```{r take1step2transform}
dfActivity$date <- ymd(dfActivity$date)
dfActivity$date <- as.factor(dfActivity$date)
dfActivity$interval <- as.factor(dfActivity$interval) 
dtActivity <- tbl_df(dfActivity)
```

The Initial Activity dataset has the following structure:
```{r task1step3demo}
str(dfActivity)
```
***
### TASK 2: "What is mean total number of steps taken per day?""
```{r task2step1}
subsetDTActivityA <- 
    dtActivity %>% 
    select( date, steps) %>%
    filter( !is.na(steps)) %>%
    group_by(date) %>%
    summarise(
        tot_steps = sum(steps),
        avg_steps = mean(steps, na.rm = TRUE),
        med_steps = median(steps, na.rm = TRUE))
```
The histogram of the total number of steps taken each day
```{r task2step2}
qplot(
    subsetDTActivityA$tot_steps,
    binwidth = 500,
    geom = "histogram", 
    main = "Histogram Registering Number of Days Reaching Step Totals",
    xlab = "Number of Steps Taken",
    ylab = "Number of Days",
    fill = I("lightgreen"), 
    colour = I("black")) 
```

Calculate and report the mean and median total number of steps taken per day
```{r task2step3}
stepReport <- subsetDTActivityA %>%
                select(date,avg_steps,med_steps)
stepReport
```

***
### TASK 3: "What is the average daily activity pattern?"
Shown below is a time series plot (i.e. type = "l") of the 5-minute interval (x-axis) and the average number of steps taken, averaged across all days (y-axis):
```{r task3step1}
# SUMMARIZE DATASET TO OBTAIN AVERAGE STEPS
subsetDTActivityB <- 
  dtActivity %>% 
  select( interval, steps) %>%
  filter( !is.na(steps) ) %>%
  group_by(interval) %>%
  summarise(average_steps = mean(steps))

subsetDTActivityB$interval <- as.numeric(subsetDTActivityB$interval) 
```
```{r task3step2}
qplot(
      interval, 
      average_steps,
      data = subsetDTActivityB,
      geom = "line",
      main = "Average Number Step Rate Record Over A Day",
      xlab = "Hour of Day [Generated from 288 5 minute Observations]",
      ylab = "Average Steps Rate") + 
    scale_x_continuous(breaks = getStepScaleBreaks(), labels = getStepScaleLabels()) +
    theme(axis.text.x = element_text(angle=90))
```

#### "Which 5-minute interval, on average across all the days in the dataset, contains the maximum number of steps?"
```{r task3step3}
subsetDTActivityC <- 
    dtActivity %>% 
    select( interval, steps) %>%
    filter( !is.na(steps) ) %>%
    group_by(interval) %>%
    summarise(average_steps = mean(steps))
maxNumberSteps <- subsetDTActivityC[subsetDTActivityC$average_steps == max(subsetDTActivityC$average_steps),]
```
####ANSWER: 
Time interval labelled: `r maxNumberSteps$interval` has the maximum average number of steps at `r maxNumberSteps$average_steps`

***
### TASK 4: Inputing Missing Values
Replacing the NAs in step count with averages of the total step count.  The Averages are rounded up to the nearest whole integer number.
```{r task4step1a, message=FALSE, echo=FALSE}
# NUMBER OF COMPLETE ROWS
totalCompleteCases <- sum(complete.cases(dtActivity) == TRUE)
# NUMBER OF COMPLETE
totalIncompleteCases<- sum(complete.cases(dtActivity) == FALSE)
```
In the provided Activity dataset, there are `r totalIncompleteCases` records that have a step count missing out of the total `r totalCompleteCases + totalIncompleteCases`

```{r task4step1b, message=FALSE}
# FILTER FOR COMPLETE VS INCOMPLETE
dtActivityComplete <- dtActivity[(complete.cases(dtActivity) == TRUE),]
dtActivityMissing <- dtActivity[(complete.cases(dtActivity) == FALSE),]

# CALCULATE INTERVAL BASED STEP AVERAGES
subsetDTActivityStepAvg <- 
  dtActivity %>% 
  select( interval, steps) %>%
  filter( !is.na(steps) ) %>%
  group_by(interval) %>%
  summarise(average_steps = mean(steps))

# LEFT JOIN THE AVERAGES TO INCOMPLETE CASES
dtActivityMissingAvg <- inner_join(x = dtActivityMissing, y = subsetDTActivityStepAvg)
# ROUND UP THE AVERAGES AND ASSIGN TO THE STEPS COLUMN
dtActivityMissingAvg$steps <- ceiling(dtActivityMissingAvg$average_steps)

# OBTAIN A NEW DATASET FOR THE FIXED MISSING CASES
dtActivityNotMissing <- dtActivityMissingAvg[, (colnames(dtActivityMissingAvg) %in% c("steps","date","interval"))]

# RECREATE A NEW COMPLETE DATASET
dtActivityUpdated <- rbind(dtActivityComplete, dtActivityNotMissing)

# SUMMARIZE THE STEPS BY TOTAL #, AVERAGE AND MEDIAN
subsetDTActivityUpdated <- 
  dtActivityUpdated %>% 
  select( date, steps) %>%
  filter( !is.na(steps) ) %>%
  group_by(date) %>%
  summarise(tot_steps = sum(steps),
            avg_steps = mean(steps),
            med_steps = median(steps))
```

```{r task4step2}
# PLOT COMPLETE CASES DATASET
qplot(subsetDTActivityUpdated$tot_steps,
      binwidth = 500,
      geom = "histogram", 
      main = "Histogram Registering Number of Days Reaching Step Totals",
      xlab = "Number of Steps Taken",
      ylab = "Number of Days",
      fill = I("orange"), 
      colour = I("black")) 
```

***
### TASK 5: Activity patterns on weekdays vs. weekends?
The follow is the logic used to add the Weekend Vs Weekend Factor Categorical factors into the data.
```{r task5step1}
# CREATE NEW FUNCTION TO RETURN THE FACTOR BASED ON THE WEEKDAYS FUNCTION
getWeekPeriod <- function(x) { 
    if (weekdays(as.POSIXct(x)) %in% c("Saturday","Sunday"))
        as.factor("WEEKEND") 
    else
        as.factor("WEEKDAY") 
}
# BIND THE NEW CONTENT TO THE EXISTING TABLE
dtFinal<- cbind(dtActivityUpdated, sapply(dtActivityUpdated$date,getWeekPeriod))
colnames(dtFinal) <- c("steps","date","interval","weekperiod")

# CALCULATE THE AVERAGES GROUPED BY WEEK-PERIOD, AND INTERVAL
dtFinal$interval <- as.numeric(dtFinal$interval)
dtFinalScrubbed <- 
    dtFinal %>% 
    group_by(weekperiod, interval) %>%
    summarise(average_steps = mean(steps))

```

The following is the plot showing the activity level differences on the weekend vs the work week days.
```{r task5step2}
p <- qplot(
        interval, 
        average_steps, 
        data = dtFinalScrubbed, 
        facets = weekperiod ~ . , 
        geom = "line",
        color = weekperiod,
        main = "Average No. of Steps Taken by Time of Day\nDivided by Weekend Period",
        xlab = "Time Interval (288 5 minute Observations by Hour)",
        ylab = "Average Steps") +
    scale_x_continuous(breaks = getStepScaleBreaks(), labels = getStepScaleLabels()) +
    theme(axis.text.x = element_text(angle=90))
p
```
